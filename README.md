# Task 2 : Hello World RTOS

This project demonstrates the creation and management of multiple tasks using RTOS (FreeRTOS) on an STM32 microcontroller with the STM32 HAL. It includes four tasks with different priorities: reading a button press, controlling an LED, reading an ADC value, and communicating via UART.

## Table of Contents

- [Task Configurations](#task-configurations)
- [Task Descriptions](#task-descriptions)
  - [pickButton Task](#pickbutton-task)
  - [getADC Task](#getadc-task)
  - [LED_LVL Task](#led_lvl-task)
  - [dispUART Task](#dispuart-task)
- [Important Notes](#important-notes)
- [Hardware Configurations](#hardware-configuration)
- [Demonstration Video](#demonstration-video)
- [Author](#author)

## Task Configurations

In the program, there are four tasks running under the RTOS (Real-Time Operating System) with different priorities:

- `pickButton()` with priority osPriorityNormal
- `LED_LVL()` with priority osPriorityNormal
- `getADC()` with priority osPriorityAboveNormal
- `dispUART()` with priority osPriorityNormal

In RTOS, tasks with higher priority will dominate the MCU's processing time. When multiple tasks are ready to run at the same time, the task with the highest priority will be executed first. We need to change the timebase source using another unused timer for the HAL timebase because, by default, SysTick is used for functions like `HAL_Delay()` and `HAL_GetTick()`. This default configuration gives SysTick a very high priority. However, FreeRTOS requires SysTick for its scheduler, and it needs a much lower priority. In this case, we use TIM4 as the timebase source.

The initial program setup and configuration are generated from the .ioc file. Let's discuss each part of the RTOS task program generated by the .ioc file.

The tasks are defined as follows:

```c
osThreadId_t pickButtonTaskHandle;
const osThreadAttr_t pickButtonTask_attributes = {
  .name = "pickButtonTask",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};

osThreadId_t LED_LVL_taskHandle;
const osThreadAttr_t LED_LVL_task_attributes = {
  .name = "LED_LVL_task",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};

osThreadId_t getADCtaskHandle;
const osThreadAttr_t getADCtask_attributes = {
  .name = "getADCtask",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityAboveNormal,
};

osThreadId_t dispUARTTaskHandle;
const osThreadAttr_t dispUARTTask_attributes = {
  .name = "dispUARTTask",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
```

The tasks are created using `osThreadNew()` and are started with `osKernelStart()`. This will initialize the task scheduler and execute tasks based on their priority and timing (via `osDelay()`).

```c
osKernelInitialize();
pickButtonTaskHandle = osThreadNew(pickButton, NULL, &pickButtonTask_attributes);
LED_LVL_taskHandle = osThreadNew(LED_LVL, NULL, &LED_LVL_task_attributes);
getADCtaskHandle = osThreadNew(getADC, NULL, &getADCtask_attributes);
dispUARTTaskHandle = osThreadNew(dispUART, NULL, &dispUARTTask_attributes);
osKernelStart();
```

## Task Descriptions

### pickButton Task

```c
void pickButton(void *argument)
{
  for(;;)
  {
    if(HAL_GPIO_ReadPin(BUTTON_GPIO_Port, BUTTON_Pin) == GPIO_PIN_RESET)
    {
      osDelay(300);
      button1_pressed = 1;
    }
    else button1_pressed = 0;
    osDelay(100);
  }
}
```

This task monitors the button press. The button is read using `HAL_GPIO_ReadPin()`. When the button is pressed (GPIO low), it sets the global variable button1_pressed to 1 after a 300 ms debounce delay. This variable can be accessed by other tasks. It continues checking the button state every 100 ms.

### getADC Task

```c
void getADC(void *argument)
{
  while(1)
  {
    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, 10);
    x_val = (HAL_ADC_GetValue(&hadc1));
    HAL_ADC_Stop(&hadc1);

    osDelay(10);
  }
}
```

This task reads the ADC value from a potentiometer. It starts the ADC conversion process using `HAL_ADC_Start()`, waits for the conversion to complete using `HAL_ADC_PollForConversion()`, and then stores the ADC value in the global variable `x_val` by calling `HAL_ADC_GetValue()`. After reading the ADC value, the task delays for 10 ms (`osDelay(10)`) before starting the next ADC reading.

### LED_LVL Task

```c
void LED_LVL(void *argument)
{
  while(1)
  {
    if(button1_pressed == 1){
      Light_LED();
      osDelay(300);
      Tf_LED();
      osDelay(300);
    }
    else Light_LED();
  }
}
```

This task controls the LED based on the ADC value (`x_val`) and the button status (`button1_pressed`). When `button1_pressed == 1` (button is pressed), the LED blinks with a 300 ms period. If the button is not pressed, the LED displays a level corresponding to the ADC value. The task is continuously checking the button status and adjusting the LED display accordingly.

### dispUART Task

```c
void dispUART(void *argument)
{
  Menu_Display();
  char buffer2[20] = "_";

  for(;;)
  {
    HAL_UART_Receive(&huart2, &choice, sizeof(choice), 10);
    if (choice == '1') {
      sprintf(buffer2, "Voltage = %d\r\n",x_val);
      HAL_UART_Transmit(&huart2, buffer2, sizeof(buffer2), 20);
    }

    if(button1_pressed)
    {
      HAL_UART_Transmit(&huart2, (uint8_t*)"Button1 pressed\r\n", sizeof("Button1 pressed\r\n"), 10);
    }

    osDelay(100);
  }
}
```

This task handles serial communication. It transmits the current ADC voltage (`x_val`) to a serial monitor when the user inputs '1' via UART. Additionally, if the button is pressed (`button1_pressed == 1`), it sends the message "Button1 pressed". The task continuously checks UART input and sends appropriate messages every 100 ms.

## Important Notes
1. **Task Communication:** The program uses global variables to share data between tasks, as global variables can be accessed by all tasks. Changing the value of these variables affects the behavior of other tasks that use them. Additionally, the use of `osDelay()` in each task ensures that all tasks run alternately, even though they have different priorities. This allows each task to be executed in a regular manner without blocking other tasks.
2. **Task Scheduling:** Task scheduling is based on priority and `osDelay()`. Higher-priority tasks (e.g., getADC) will preempt lower-priority tasks (e.g., LED_LVL) if they are ready to run.
3. **Global Variables:** The tasks communicate using global variables (`button1_pressed and x_val`) which can be accessed and modified by multiple tasks.
4. **SysTick Usage:** To avoid conflicts between HAL and FreeRTOS, TIM4 is used as the timebase source instead of SysTick.


## Hardware Configuration
The .ioc configuration file is used to initialize and set up the project. Key configurations include setting up the ADC, GPIO, UART, and assigning the timebase to TIM4 instead of SysTick for proper RTOS scheduling.

![alt text](https://github.com/yogadana/Real-Time-Operating-System-Subject/blob/main/task2_Hello_World_RTOS/ioc.png?raw=true "ioc")

![WhatsApp Image 2024-10-17 at 21 01 12_41b27a31](https://github.com/user-attachments/assets/4245ddae-e164-4c1f-95f7-ef10a7236669)


## Demonstration Video

https://github.com/user-attachments/assets/18828054-0750-439d-96a9-19b5cc5db68d


## Author
- Dana Yoga Setya Ikhwandi (3222600016)
- Nio Perdana Azizudin (3222600022)
